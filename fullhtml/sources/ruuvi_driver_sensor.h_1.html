
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>ruuvi_driver_sensor.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#ifndef RUUVI_DRIVER_SENSOR_H</a>
<a name="ln2">#define RUUVI_DRIVER_SENSOR_H</a>
<a name="ln3">/**</a>
<a name="ln4"> * @defgroup Sensor Common sensor interface</a>
<a name="ln5"> * @brief Functions for setting up and using sensors</a>
<a name="ln6"> *</a>
<a name="ln7"> *</a>
<a name="ln8"> */</a>
<a name="ln9">/** @{ */</a>
<a name="ln10">/**</a>
<a name="ln11"> * @file ruuvi_driver_sensor.h</a>
<a name="ln12"> * @author Otso Jousimaa &lt;otso@ojousima.net&gt;</a>
<a name="ln13"> * @date 2020-06-01</a>
<a name="ln14"> * @copyright Ruuvi Innovations Ltd, license BSD-3-Clause</a>
<a name="ln15"> * @brief Ruuvi sensor interface &lt;b&gt;Lifecycle: Beta&lt;/b&gt;</a>
<a name="ln16"> *</a>
<a name="ln17"> *</a>
<a name="ln18"> *</a>
<a name="ln19"> * Common interface to all Ruuvi Sensors</a>
<a name="ln20"> * Every sensor must implement these functions:</a>
<a name="ln21"> * - init</a>
<a name="ln22"> * - uninit</a>
<a name="ln23"> * - samplerate_set</a>
<a name="ln24"> * - samplerate_get</a>
<a name="ln25"> * - dsp_set</a>
<a name="ln26"> * - dsp_get</a>
<a name="ln27"> * - scale_set</a>
<a name="ln28"> * - scale_set</a>
<a name="ln29"> * - resolution_set</a>
<a name="ln30"> * - resolution_get</a>
<a name="ln31"> * - mode_set</a>
<a name="ln32"> * - mode_get</a>
<a name="ln33"> * - data_get</a>
<a name="ln34"> *</a>
<a name="ln35"> * If function does not make sense for the sensor, it will return error code.</a>
<a name="ln36"> *</a>
<a name="ln37"> * Return name: Return a pointer to a constant 8-byte long string which represensts sensor, e.g. LIS2DH12\0 or BME280\0\0</a>
<a name="ln38"> *</a>
<a name="ln39"> * INIT, UNINT: Init will prepare sensor for use, reset the sensor, run self-test and place it in low-power mode. Additionally function pointers will be set up by init.</a>
<a name="ln40"> *              Uninit will release any resources used by sensor</a>
<a name="ln41"> *</a>
<a name="ln42"> * Samplerate: Applicable on continuous mode, how often sensor takes samples. Hz</a>
<a name="ln43"> *</a>
<a name="ln44"> * DSP: DSP function and parameter, i.e. &quot;OVERSAMPLING, 16&quot;. Return error if the device does not support it.</a>
<a name="ln45"> *</a>
<a name="ln46"> * scale: Maximum scale in a meaningful physical unit, such as celcius or pascal.</a>
<a name="ln47"> *</a>
<a name="ln48"> * resolution: Resolution in bits.</a>
<a name="ln49"> *</a>
<a name="ln50"> * mode: Sleep, single, continuous.</a>
<a name="ln51"> *  - Sleep mode should enter lowest-power state available</a>
<a name="ln52"> *  - Single will return once new data is available with data_get call</a>
<a name="ln53"> *  - Continuous: Sensor will sample at given rate. Returns immediately, data will be available after first sample</a>
<a name="ln54"> *</a>
<a name="ln55"> * data get: return latest sample from sensor</a>
<a name="ln56"> */</a>
<a name="ln57"> </a>
<a name="ln58">#include &quot;ruuvi_driver_error.h&quot;</a>
<a name="ln59">#include &lt;stdbool.h&gt;</a>
<a name="ln60">#include &lt;stddef.h&gt;</a>
<a name="ln61">#include &lt;stdint.h&gt;</a>
<a name="ln62"> </a>
<a name="ln63">#define RD_SENSOR_INVALID_VALUE    RD_FLOAT_INVALID  //!&lt; Signal this sensor value is erroneous</a>
<a name="ln64">#define RD_SENSOR_INVALID_TIMSTAMP RD_UINT64_INVALID //!&lt; Signal this timestamp value is erroneous</a>
<a name="ln65"> </a>
<a name="ln66">// Constants for sensor configuration and status</a>
<a name="ln67">#define RD_SENSOR_CFG_DEFAULT         (0U)      //!&lt; Default value, always valid for the sensor.</a>
<a name="ln68">#define RD_SENSOR_CFG_CUSTOM_1        (0xC9U)   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln69">#define RD_SENSOR_CFG_CUSTOM_2        (0xCAU)   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln70">#define RD_SENSOR_CFG_CUSTOM_3        (0xCBU)   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln71">#define RD_SENSOR_CFG_CUSTOM_4        (0xCCU)   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln72">#define RD_SENSOR_CFG_CUSTOM_5        (0xCDU)   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln73">#define RD_SENSOR_CFG_CUSTOM_6        (0xCEU)   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln74">#define RD_SENSOR_ERR_INVALID         (0xE0U)   //!&lt; Error code, given parameter is invalid</a>
<a name="ln75">#define RD_SENSOR_ERR_NOT_IMPLEMENTED (0xE1U)   //!&lt; Error code, given parameter is not implemented (todo)</a>
<a name="ln76">#define RD_SENSOR_ERR_NOT_SUPPORTED   (0xE2U)   //!&lt; Error code, given parameter is not supported by sensor</a>
<a name="ln77">#define RD_SENSOR_CFG_MIN             (0xF0U)   //!&lt; Configure smallest supported and implemented value</a>
<a name="ln78">#define RD_SENSOR_CFG_MAX             (0xF1U)   //!&lt; Configure largest supported and implemented value</a>
<a name="ln79">#define RD_SENSOR_CFG_SLEEP           (0xF2U)   //!&lt; Sensor should go to sleep immediately</a>
<a name="ln80">#define RD_SENSOR_CFG_SINGLE          (0xF3U)   //!&lt; Sensor should go to sleep after single measurement</a>
<a name="ln81">#define RD_SENSOR_CFG_CONTINUOUS      (0xF4U)   //!&lt; Sensor will keep sampling at defined sample rate</a>
<a name="ln82">#define RD_SENSOR_CFG_NO_CHANGE       (0xFFU)   //!&lt; Do not change configured value</a>
<a name="ln83"> </a>
<a name="ln84">// DSP functions, complemented by DSP parameter</a>
<a name="ln85">#define RD_SENSOR_DSP_LAST            (0U)    //!&lt; Return last value from sensor. Parameter: No effect. Use default</a>
<a name="ln86">#define RD_SENSOR_DSP_LOW_PASS        (1U&lt;&lt;1U) //!&lt; Low pass sensor values Parameter: coefficient</a>
<a name="ln87">#define RD_SENSOR_DSP_HIGH_PASS       (1U&lt;&lt;2U) //!&lt; High pass sensor values Parameter: coefficient</a>
<a name="ln88">#define RD_SENSOR_DSP_OS              (1U&lt;&lt;3U) //!&lt; Oversample sensor values. Parameter: Number of samples</a>
<a name="ln89"> </a>
<a name="ln90">/** @brief convert Ruuvi GPIO into uint8_t */</a>
<a name="ln91">#define RD_GPIO_TO_HANDLE(handle) ((((handle) &gt;&gt; 3U) &amp; 0xE0U) + ((handle) &amp; 0x1FU))</a>
<a name="ln92">/** @brief convert uint8_t into Ruuvi GPIO */</a>
<a name="ln93">#define RD_HANDLE_TO_GPIO(handle) ((((handle) &amp; 0xE0U) &lt;&lt; 3U) + ((handle) &amp; 0x1FU))</a>
<a name="ln94">/** @brief Mark sensor as unused with this handle */</a>
<a name="ln95">#define RD_HANDLE_UNUSED (0xFFU)</a>
<a name="ln96"> </a>
<a name="ln97">#ifndef UNUSED_VARIABLE</a>
<a name="ln98">#   define UNUSED_VARIABLE(X)  ((void)(X))</a>
<a name="ln99">#endif</a>
<a name="ln100"> </a>
<a name="ln101">/**</a>
<a name="ln102"> * @brief All sensors must implement configuration functions which accept this struct.</a>
<a name="ln103"> */</a>
<a name="ln104">typedef struct __attribute__ ( (packed, aligned (4)))</a>
<a name="ln105">{</a>
<a name="ln106">    uint8_t samplerate;     //!&lt; Samplerate, in Hz</a>
<a name="ln107">    uint8_t resolution;     //!&lt; Resolution, in bits</a>
<a name="ln108">    uint8_t scale;          //!&lt; Scale, in relevant Si-unit</a>
<a name="ln109">    uint8_t dsp_function;   //!&lt; DSP function, one of @c RD_SENSOR_DSP_*</a>
<a name="ln110">    uint8_t dsp_parameter;  //!&lt; Parameter to DSP functions</a>
<a name="ln111">    uint8_t mode;           //!&lt; Mode, RD_SENSOR_SLEEP, _SINGLE, _CONTINOUS</a>
<a name="ln112">    uint8_t reserved0;      //!&lt; Reserved for future use</a>
<a name="ln113">    uint8_t reserved1;      //!&lt; Reserved for future use</a>
<a name="ln114">}</a>
<a name="ln115">rd_sensor_configuration_t;</a>
<a name="ln116"> </a>
<a name="ln117">/**</a>
<a name="ln118"> * @brief Type of bus sensor uses.</a>
<a name="ln119"> */</a>
<a name="ln120">typedef enum</a>
<a name="ln121">{</a>
<a name="ln122">    RD_BUS_NONE = 0U, //!&lt; No bus, internal to IC</a>
<a name="ln123">    RD_BUS_SPI  = 1U, //!&lt; SPI bus</a>
<a name="ln124">    RD_BUS_I2C  = 2U, //!&lt; I2C bus</a>
<a name="ln125">    RD_BUS_UART = 3U, //!&lt; UART bus</a>
<a name="ln126">    RD_BUS_PDM  = 4U, //!&lt; PDM bus</a>
<a name="ln127">    RD_BUS_FAIL = 5U  //!&lt; Test behaviour on invalid bus with this value.</a>
<a name="ln128">} rd_bus_t;</a>
<a name="ln129"> </a>
<a name="ln130">/**</a>
<a name="ln131"> * @brief Bitfield to describe related sensor data</a>
<a name="ln132"> */</a>
<a name="ln133">typedef struct</a>
<a name="ln134">{</a>
<a name="ln135">    unsigned int acceleration_x_g : 1; //!&lt; Acceleration along X-axis, gravities.</a>
<a name="ln136">    unsigned int acceleration_y_g : 1; //!&lt; Acceleration along Y-axis, gravities.</a>
<a name="ln137">    unsigned int acceleration_z_g : 1; //!&lt; Acceleration along Z-axis, gravities.</a>
<a name="ln138">    unsigned int co2_ppm : 1;          //!&lt; CO2, Parts per million.</a>
<a name="ln139">    unsigned int gyro_x_dps : 1;       //!&lt; Rotation along X-axis, degrees per second.</a>
<a name="ln140">    unsigned int gyro_y_dps : 1;       //!&lt; Rotation along Y-axis, degrees per second.</a>
<a name="ln141">    unsigned int gyro_z_dps : 1;       //!&lt; Rotation along Z-axis, degrees per second.</a>
<a name="ln142">    unsigned int humidity_rh : 1;      //!&lt; Relative humidity, %.</a>
<a name="ln143">    /** @brief Light level, dimensionless. Comparable only between identical devices. */</a>
<a name="ln144">    unsigned int luminosity  : 1;</a>
<a name="ln145">    unsigned int magnetometer_x_g : 1; //!&lt; Magnetic flux along X-axis, Gauss.</a>
<a name="ln146">    unsigned int magnetometer_y_g : 1; //!&lt; Magnetic flux along Y-axis, Gauss.</a>
<a name="ln147">    unsigned int magnetometer_z_g : 1; //!&lt; Magnetic flux along Z-axis, Gauss.</a>
<a name="ln148">    unsigned int pm_1_ugm3 : 1;        //!&lt; Ultra-fine particulate matter, microgram per m^3.</a>
<a name="ln149">    unsigned int pm_2_ugm3 : 1;        //!&lt; Fine particulate matter, microgram per m^3.</a>
<a name="ln150">    unsigned int pm_4_ugm3 : 1;        //!&lt; Medium particulate matter, microgram per m^3.</a>
<a name="ln151">    unsigned int pm_10_ugm3 : 1;       //!&lt; Coarse particulate matter, microgram per m^3.</a>
<a name="ln152">    unsigned int pressure_pa : 1;      //!&lt; Pressure, pascals</a>
<a name="ln153">    unsigned int spl_dbz : 1;          //!&lt; Unweighted sound pressure level.</a>
<a name="ln154">    unsigned int temperature_c : 1;    //!&lt; Temperature, celcius</a>
<a name="ln155">    unsigned int voc_ppm : 1;          //!&lt; Volatile organic compounds, parts per million.</a>
<a name="ln156">    unsigned int voltage_v : 1;        //!&lt; Voltage, volts.</a>
<a name="ln157">    unsigned int voltage_ratio : 1;    //!&lt; Voltage, ratio to maximum</a>
<a name="ln158">    unsigned int reserved: 10;         //!&lt; Reserved bits, force remainder of bitfield to 0.</a>
<a name="ln159">} rd_sensor_data_bitfield_t;</a>
<a name="ln160"> </a>
<a name="ln161">/**</a>
<a name="ln162"> * C99 Standard 6.7.8.21</a>
<a name="ln163"> * If there are fewer initializers in a brace-enclosed list than there are</a>
<a name="ln164"> * elements or members of an aggregate, or fewer characters in a string literal</a>
<a name="ln165"> * used to initialize an array of known size than there are elements in the array,</a>
<a name="ln166"> * the remainder of the aggregate shall be initialized implicitly the same as</a>
<a name="ln167"> * objects that have static storage duration.</a>
<a name="ln168"> */</a>
<a name="ln169">/** @brief Shorthand for calling rd_sensor_data_parse(p_data, FIELD) */</a>
<a name="ln170">#define RD_SENSOR_ACC_X_FIELD ((rd_sensor_data_fields_t){.datas.acceleration_x_g=1})</a>
<a name="ln171">/** @brief Shorthand for calling rd_sensor_data_parse(p_data, FIELD) */</a>
<a name="ln172">#define RD_SENSOR_ACC_Y_FIELD ((rd_sensor_data_fields_t){.datas.acceleration_y_g=1})</a>
<a name="ln173">/** @brief Shorthand for calling rd_sensor_data_parse(p_data, FIELD) */</a>
<a name="ln174">#define RD_SENSOR_ACC_Z_FIELD ((rd_sensor_data_fields_t){.datas.acceleration_z_g=1})</a>
<a name="ln175">/** @brief Shorthand for calling rd_sensor_data_parse(p_data, FIELD) */</a>
<a name="ln176">#define RD_SENSOR_GYR_X_FIELD ((rd_sensor_data_fields_t){.datas.gyro_x_dps=1})</a>
<a name="ln177">/** @brief Shorthand for calling rd_sensor_data_parse(p_data, FIELD) */</a>
<a name="ln178">#define RD_SENSOR_GYR_Y_FIELD ((rd_sensor_data_fields_t){.datas.gyro_y_dps=1})</a>
<a name="ln179">/** @brief Shorthand for calling rd_sensor_data_parse(p_data, FIELD) */</a>
<a name="ln180">#define RD_SENSOR_GYR_Z_FIELD ((rd_sensor_data_fields_t){.datas.gyro_z_dps=1})</a>
<a name="ln181">/** @brief Shorthand for calling rd_sensor_data_parse(p_data, FIELD) */</a>
<a name="ln182">#define RD_SENSOR_HUMI_FIELD ((rd_sensor_data_fields_t){.datas.humidity_rh=1})</a>
<a name="ln183">/** @brief Shorthand for calling rd_sensor_data_parse(p_data, FIELD) */</a>
<a name="ln184">#define RD_SENSOR_PRES_FIELD ((rd_sensor_data_fields_t){.datas.pressure_pa=1})</a>
<a name="ln185">/** @brief Shorthand for calling rd_sensor_data_parse(p_data, FIELD) */</a>
<a name="ln186">#define RD_SENSOR_TEMP_FIELD ((rd_sensor_data_fields_t){.datas.temperature_c=1})</a>
<a name="ln187"> </a>
<a name="ln188"> </a>
<a name="ln189"> </a>
<a name="ln190">/**</a>
<a name="ln191"> * @brief Union to access sensor data.</a>
<a name="ln192"> *</a>
<a name="ln193"> * MISRA deviation: Use of union.</a>
<a name="ln194"> * Union is used here for fast operations on sensor data through field bitfield</a>
<a name="ln195"> * and to give a meaningful value to each bit through datas.</a>
<a name="ln196"> *</a>
<a name="ln197"> * C99 and onwards allow type punning, but this is not portable to C++.</a>
<a name="ln198"> * Run the integration tests on your platform.</a>
<a name="ln199"> *</a>
<a name="ln200"> */</a>
<a name="ln201">typedef union // -V2514</a>
<a name="ln202">{</a>
<a name="ln203">    uint32_t bitfield; //!&lt; Bitfield used to access sensor data.</a>
<a name="ln204">    rd_sensor_data_bitfield_t datas; //!&lt; Structured data field.</a>
<a name="ln205">} rd_sensor_data_fields_t;</a>
<a name="ln206"> </a>
<a name="ln207">/**</a>
<a name="ln208"> * @brief Generic sensor data struct.</a>
<a name="ln209"> *</a>
<a name="ln210"> * The data sensor struct contains a timestamp relative to sensor boot,</a>
<a name="ln211"> * a list of fields contained within the sensor data and a pointer to array</a>
<a name="ln212"> * of floats which contain the actual data.</a>
<a name="ln213"> */</a>
<a name="ln214">typedef struct rd_sensor_data_t</a>
<a name="ln215">{</a>
<a name="ln216">    uint64_t timestamp_ms;      //!&lt; Timestamp of the event, @ref rd_sensor_timestamp_get.</a>
<a name="ln217">    rd_sensor_data_fields_t</a>
<a name="ln218">    fields; //!&lt; Description of datafields which may be contained in this sample.</a>
<a name="ln219">    rd_sensor_data_fields_t valid;  //!&lt; Listing of valid data in this sample.</a>
<a name="ln220">    /** @brief Data of sensor. Must contain as many elements as fields has bits set. */</a>
<a name="ln221">    float * data;</a>
<a name="ln222">} rd_sensor_data_t;</a>
<a name="ln223"> </a>
<a name="ln224">/** @brief Forward declare type definition of sensor structure */</a>
<a name="ln225">typedef struct rd_sensor_t rd_sensor_t;</a>
<a name="ln226"> </a>
<a name="ln227">/**</a>
<a name="ln228"> * @brief Initialize and uninitialize sensor.</a>
<a name="ln229"> * Init and uninit will setup sensor with function pointers.</a>
<a name="ln230"> * The sensor wil be initialized to lowest power state possible.</a>
<a name="ln231"> *</a>
<a name="ln232"> * @param[in,out] p_sensor pointer to sensor structure</a>
<a name="ln233"> * @param[in] bus bus to use, i.r. I2C or SPI</a>
<a name="ln234"> * @param[in] handle for the sensor, for example I2C address or SPI chip select pin</a>
<a name="ln235"> * @return @c RD_SUCCESS on success</a>
<a name="ln236"> * @return @c RD_ERROR_NULL if p_sensor is NULL</a>
<a name="ln237"> * @return @c RD_ERROR_NOT_FOUND if there is no response from sensor or if ID of</a>
<a name="ln238"> *            a sensor read over bus does not match expected value</a>
<a name="ln239"> * @return @c RD_ERROR_SELFTEST if sensor is found but it does not pass selftest</a>
<a name="ln240"> * @return @c RD_ERROR_INVALID_STATE if trying to initialize sensor which</a>
<a name="ln241"> *            already has been initialized.</a>
<a name="ln242"> **/</a>
<a name="ln243">typedef rd_status_t (*rd_sensor_init_fp) (rd_sensor_t * const</a>
<a name="ln244">        p_sensor, const rd_bus_t bus, const uint8_t handle);</a>
<a name="ln245"> </a>
<a name="ln246">/**</a>
<a name="ln247"> *  @brief Setup a parameter of a sensor.</a>
<a name="ln248"> *  The function will modify the pointed data to the actual value which was written</a>
<a name="ln249"> *</a>
<a name="ln250"> *  @param[in,out] parameter value to write to sensor configuration. Actual value written to sensor as output</a>
<a name="ln251"> *  @return RD_SUCCESS on success</a>
<a name="ln252"> *  @return RD_ERROR_NULL if parameter is NULL</a>
<a name="ln253"> *  @return RD_ERROR_NOT_SUPPORTED if sensor cannot support given parameter</a>
<a name="ln254"> *  @return RD_ERROR_NOT_IMPLEMENTED if the sensor could support parameter, but it's not implemented in fw.</a>
<a name="ln255"> **/</a>
<a name="ln256">typedef rd_status_t (*rd_sensor_setup_fp) (uint8_t * parameter);</a>
<a name="ln257"> </a>
<a name="ln258">/**</a>
<a name="ln259"> * @brief Configure sensor digital signal processing.</a>
<a name="ln260"> * Takes DSP function and a DSP parameter as input, configured value or error code as output.</a>
<a name="ln261"> * Modifies input parameters to actual values written on the sensor.</a>
<a name="ln262"> * DSP functions are run on the sensor HW, not in the platform FW.</a>
<a name="ln263"> *</a>
<a name="ln264"> * @param[in,out] dsp_function. DSP function to run on sensor. Can be a combination of several functions.</a>
<a name="ln265"> * @param[in,out] dsp_parameter. Parameter to DSP function(s)</a>
<a name="ln266"> * @return RD_SUCCESS on success</a>
<a name="ln267"> * @return RD_ERROR_NULL if either parameter is NULL</a>
<a name="ln268"> * @return RD_ERROR_NOT_SUPPORTED if sensor doesn't support given DSP</a>
<a name="ln269"> * @return RD_ERROR_NOT_IMPLEMENTED if sensor supports given DSP, but</a>
<a name="ln270"> *         driver does not implement it</a>
<a name="ln271"> * @return RD_ERROR_INVALID_PARAM if parameter is invalid for any reason.</a>
<a name="ln272"> **/</a>
<a name="ln273">typedef rd_status_t (*rd_sensor_dsp_fp) (uint8_t * dsp_function,</a>
<a name="ln274">        uint8_t * dsp_parameter);</a>
<a name="ln275"> </a>
<a name="ln276">/**</a>
<a name="ln277"> * @brief Read latest data from sensor registers</a>
<a name="ln278"> * Return latest data from sensor. Does not take a new sample, calling this function twice</a>
<a name="ln279"> * in a row returns same data. Configure sensor in a single-shot mode to take a new sample</a>
<a name="ln280"> * or leave sensor in a continuous mode to get updated data.</a>
<a name="ln281"> *</a>
<a name="ln282"> * p_data may contain, some, none or all of fields sensor is able to provide.</a>
<a name="ln283"> * Fields which are already marked as valid will not be overwritten, filled fields</a>
<a name="ln284"> * will get marked as valid.</a>
<a name="ln285"> *</a>
<a name="ln286"> * @param [out] p_data Pointer to sensor data @ref rd_sensor_data_t .</a>
<a name="ln287"> * @return RD_SUCCESS on success</a>
<a name="ln288"> * @return RD_ERROR_NULL if p_data is @c NULL.</a>
<a name="ln289"> *</a>
<a name="ln290"> */</a>
<a name="ln291">typedef rd_status_t (*rd_sensor_data_fp) (rd_sensor_data_t * const p_data);</a>
<a name="ln292"> </a>
<a name="ln293">/**</a>
<a name="ln294"> * @brief Convenience function to write/read entire configuration in one call.</a>
<a name="ln295"> * Modifies input parameters to actual values written on the sensor.</a>
<a name="ln296"> *</a>
<a name="ln297"> * @param[in] p_sensor sensor to configure</a>
<a name="ln298"> * @param[in,out] p_configuration Input: desired configuration. Output:</a>
<a name="ln299"> *                configuration written to sensot.</a>
<a name="ln300"> * @retval RD_SUCCESS if sensor was configured successfully.</a>
<a name="ln301"> * @retval RD_ERROR_NULL if one of parameters is NULL</a>
<a name="ln302"> * @return Error code from driver on other error.</a>
<a name="ln303"> **/</a>
<a name="ln304">typedef rd_status_t (*rd_configuration_fp) (</a>
<a name="ln305">    const rd_sensor_t * const p_sensor,</a>
<a name="ln306">    rd_sensor_configuration_t * const p_configuration);</a>
<a name="ln307"> </a>
<a name="ln308">/**</a>
<a name="ln309">* @brief Read First-in-first-out (FIFO) buffer in sensor.</a>
<a name="ln310">* Reads up to num_elements data points from FIFO and populates pointer data with them.</a>
<a name="ln311">*</a>
<a name="ln312">* @param[in, out] num_elements Input: number of elements in data.</a>
<a name="ln313">                               Output: Number of elements placed in data.</a>
<a name="ln314">* @param[out] Data array of  with num_elements slots.</a>
<a name="ln315">* @retval RD_SUCCESS on success.</a>
<a name="ln316">* @retval RD_ERROR_NULL if either parameter is NULL.</a>
<a name="ln317">* @retval RD_ERROR_INVALID_STATE if FIFO is not in use.</a>
<a name="ln318">* @retval RD_ERROR_NOT_SUPPORTED if the sensor does not have FIFO.</a>
<a name="ln319">* @return error code from stack on error.</a>
<a name="ln320">*/</a>
<a name="ln321">typedef rd_status_t (*rd_sensor_fifo_read_fp) (size_t * const num_elements,</a>
<a name="ln322">        rd_sensor_data_t * const data);</a>
<a name="ln323"> </a>
<a name="ln324">/**</a>
<a name="ln325">* @brief Enable FIFO or FIFO interrupt full interrupt on sensor.</a>
<a name="ln326">* FIFO interrupt Triggers an interrupt once FIFO is filled.</a>
<a name="ln327">* It is responsibility of application to know the routing of and polarity of GPIO pins and</a>
<a name="ln328">* configure the GPIO to register interrupts.</a>
<a name="ln329">*</a>
<a name="ln330">* @param[in] enable True to enable interrupt, false to disable interrupt</a>
<a name="ln331">* @return RD_SUCCESS on success, error code from stack otherwise.</a>
<a name="ln332">**/</a>
<a name="ln333">typedef rd_status_t (*rd_sensor_fifo_enable_fp) (const bool enable);</a>
<a name="ln334"> </a>
<a name="ln335">/**</a>
<a name="ln336">* @brief Enable level interrupt on sensor.</a>
<a name="ln337">*</a>
<a name="ln338">* Triggers as ACTIVE HIGH interrupt while detected data is above threshold.</a>
<a name="ln339">*</a>
<a name="ln340">* Trigger is symmetric, i.e. threshold is valid for above positive or below negative</a>
<a name="ln341">* of given value.</a>
<a name="ln342">*</a>
<a name="ln343">* On accelerometer data is high-passed to filter out gravity.</a>
<a name="ln344">* Axes are examined individually, compound data won't trigger the interrupt. e.g.</a>
<a name="ln345">* accelerometer showing 0.8 G along X, Y, Z axes won't trigger at threshold of 1 G,</a>
<a name="ln346">* even though the vector sum of axes is larger than 1 G.</a>
<a name="ln347">*</a>
<a name="ln348">* It is responsibility of application to know the GPIO routing and register</a>
<a name="ln349">* GPIO interrupts.</a>
<a name="ln350">*</a>
<a name="ln351">* @param[in] enable  True to enable interrupt, false to disable interrupt</a>
<a name="ln352">* @param[in,out] limit_g: Input: Desired acceleration to trigger the interrupt.</a>
<a name="ln353">*                         Is considered as &quot;at least&quot;, the acceleration is rounded up to</a>
<a name="ln354">*                         next value.</a>
<a name="ln355">*                         Output: written with value that was set to interrupt</a>
<a name="ln356">* @retval RD_SUCCESS on success.</a>
<a name="ln357">* @retval RD_INVALID_STATE if data limit is higher than maximum scale.</a>
<a name="ln358">* @return error code from stack on error.</a>
<a name="ln359">*</a>
<a name="ln360">*/</a>
<a name="ln361">typedef rd_status_t (*rd_sensor_level_interrupt_use_fp) (const bool enable,</a>
<a name="ln362">        float * limit_g);</a>
<a name="ln363"> </a>
<a name="ln364">/**</a>
<a name="ln365"> * @brief Return number of milliseconds since the start of RTC.</a>
<a name="ln366"> *</a>
<a name="ln367"> * @return milliseconds since start of RTC.</a>
<a name="ln368"> * @return RD_UINT64T_INVALID if RTC is not running</a>
<a name="ln369"> */</a>
<a name="ln370">typedef uint64_t (*rd_sensor_timestamp_fp) (void);</a>
<a name="ln371"> </a>
<a name="ln372">/**</a>
<a name="ln373"> * @brief Interface to sensor.</a>
<a name="ln374"> * Some sensors can implement additional functions.</a>
<a name="ln375"> * The additional functions are defined in the interface of the sensor.</a>
<a name="ln376"> */</a>
<a name="ln377">typedef struct rd_sensor_t</a>
<a name="ln378">{</a>
<a name="ln379">    /** @brief Sensor human-readable name. Should be at most 8 bytes long. */</a>
<a name="ln380">    const char * name;</a>
<a name="ln381">    /** @brief handle for sensor internal context */</a>
<a name="ln382">    void * p_ctx;</a>
<a name="ln383">    /** @brief Description of data fields the sensor is able to provide. */</a>
<a name="ln384">    rd_sensor_data_fields_t provides;</a>
<a name="ln385">    /** @brief @ref rd_sensor_init_fp */</a>
<a name="ln386">    rd_sensor_init_fp  init;</a>
<a name="ln387">    /** @brief @ref rd_sensor_init_fp */</a>
<a name="ln388">    rd_sensor_init_fp  uninit;</a>
<a name="ln389">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln390">    rd_sensor_setup_fp samplerate_set;</a>
<a name="ln391">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln392">    rd_sensor_setup_fp samplerate_get;</a>
<a name="ln393">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln394">    rd_sensor_setup_fp resolution_set;</a>
<a name="ln395">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln396">    rd_sensor_setup_fp resolution_get;</a>
<a name="ln397">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln398">    rd_sensor_setup_fp scale_set;</a>
<a name="ln399">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln400">    rd_sensor_setup_fp scale_get;</a>
<a name="ln401">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln402">    rd_sensor_setup_fp mode_set;</a>
<a name="ln403">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln404">    rd_sensor_setup_fp mode_get;</a>
<a name="ln405">    /** @brief @ref rd_sensor_dsp_fp */</a>
<a name="ln406">    rd_sensor_dsp_fp   dsp_set;</a>
<a name="ln407">    /** @brief @ref rd_sensor_dsp_fp */</a>
<a name="ln408">    rd_sensor_dsp_fp   dsp_get;</a>
<a name="ln409">    /** @brief @ref rd_configuration_fp */</a>
<a name="ln410">    rd_configuration_fp configuration_set;</a>
<a name="ln411">    /** @brief @ref rd_configuration_fp */</a>
<a name="ln412">    rd_configuration_fp configuration_get;</a>
<a name="ln413">    /** @brief @ref rd_sensor_data_fp */</a>
<a name="ln414">    rd_sensor_data_fp   data_get;</a>
<a name="ln415">    /** @brief @速ef rd_sensor_fifo_enable_fp */</a>
<a name="ln416">    rd_sensor_fifo_enable_fp fifo_enable;</a>
<a name="ln417">    /** @brief @速ef rd_sensor_level_interrupt_use_fp */</a>
<a name="ln418">    rd_sensor_fifo_enable_fp fifo_interrupt_enable;</a>
<a name="ln419">    /** @brief @速ef rd_sensor_level_interrupt_use_fp */</a>
<a name="ln420">    rd_sensor_fifo_read_fp   fifo_read;</a>
<a name="ln421">    /** @brief @速ef rd_sensor_level_interrupt_use_fp */</a>
<a name="ln422">    rd_sensor_level_interrupt_use_fp level_interrupt_set;</a>
<a name="ln423">} rd_sensor_t;</a>
<a name="ln424"> </a>
<a name="ln425">/**</a>
<a name="ln426"> * @brief Implementation of ref rd_configuration_fp</a>
<a name="ln427"> */</a>
<a name="ln428">rd_status_t rd_sensor_configuration_set (const rd_sensor_t *</a>
<a name="ln429">        sensor, rd_sensor_configuration_t * config);</a>
<a name="ln430"> </a>
<a name="ln431">/**</a>
<a name="ln432"> * @brief Implementation of ref rd_configuration_fp</a>
<a name="ln433"> */</a>
<a name="ln434">rd_status_t rd_sensor_configuration_get (const rd_sensor_t *</a>
<a name="ln435">        sensor, rd_sensor_configuration_t * config);</a>
<a name="ln436"> </a>
<a name="ln437">/**</a>
<a name="ln438"> * @brief Setup timestamping.</a>
<a name="ln439"> * Set to @c NULL to disable timestamps.</a>
<a name="ln440"> *</a>
<a name="ln441"> * @param[in] timestamp_fp Function pointer to @ref rd_sensor_timestamp_fp implementation</a>
<a name="ln442"> * @retval RD_SUCCESS.</a>
<a name="ln443"> */</a>
<a name="ln444">rd_status_t rd_sensor_timestamp_function_set (</a>
<a name="ln445">    const rd_sensor_timestamp_fp  timestamp_fp);</a>
<a name="ln446"> </a>
<a name="ln447">/**</a>
<a name="ln448"> * @brief Calls the timestamp function and returns its value.</a>
<a name="ln449"> * @return milliseconds since the start of RTC.</a>
<a name="ln450"> * @retval RD_UINT64_INVALID if timestamp function is NULL</a>
<a name="ln451"> */</a>
<a name="ln452">uint64_t rd_sensor_timestamp_get (void);</a>
<a name="ln453"> </a>
<a name="ln454">/**</a>
<a name="ln455"> * @brief Initialize sensor struct with non-null pointers which</a>
<a name="ln456"> *        return RD_ERROR_NOT_INITIALIZED.</a>
<a name="ln457"> *</a>
<a name="ln458"> * This function is to ensure that NULL function pointers won't be called.</a>
<a name="ln459"> * If name was NULL before calling this, name will point to &quot;NOTINIT&quot;.</a>
<a name="ln460"> * If name was already set, it won't be changed.</a>
<a name="ln461"> *</a>
<a name="ln462"> * @param[out] p_sensor pointer to sensor struct to initialize.</a>
<a name="ln463"> */</a>
<a name="ln464">void rd_sensor_initialize (rd_sensor_t * const p_sensor);</a>
<a name="ln465"> </a>
<a name="ln466">/**</a>
<a name="ln467"> * @brief Mark sensor as uninitialized by calling the generic initialization.</a>
<a name="ln468"> * Will not clear the name of the sensor.</a>
<a name="ln469"> *</a>
<a name="ln470"> * @param[out] p_sensor pointer to sensor struct to uninitialize.</a>
<a name="ln471"> */</a>
<a name="ln472">void rd_sensor_uninitialize (rd_sensor_t * const p_sensor);</a>
<a name="ln473"> </a>
<a name="ln474">/**</a>
<a name="ln475"> * @brief Check if given sensor structure is already initialized.</a>
<a name="ln476"> *</a>
<a name="ln477"> * @param[in] sensor Sensor interface to check.</a>
<a name="ln478"> * @return true if structure is initialized, false otherwise.</a>
<a name="ln479"> */</a>
<a name="ln480">bool rd_sensor_is_init (const rd_sensor_t * const sensor);</a>
<a name="ln481"> </a>
<a name="ln482">/**</a>
<a name="ln483"> * @brief Populate given target data with data provided by sensor as requested.</a>
<a name="ln484"> *</a>
<a name="ln485"> * This function looks up the appropriate assigments on each data field in given target</a>
<a name="ln486"> * and populates it with provided data if caller requested the field to be populated.</a>
<a name="ln487"> * Populated fields are marked as valid.</a>
<a name="ln488"> *</a>
<a name="ln489"> * Example: Board can have these sensors in this order of priority:</a>
<a name="ln490"> *  - TMP117 (temperature)</a>
<a name="ln491"> *  - SHTC3 (temperature, humidity)</a>
<a name="ln492"> *  - DPS310 (temperature, pressure)</a>
<a name="ln493"> *  - LIS2DH12 (acceleration, temperature)</a>
<a name="ln494"> *</a>
<a name="ln495"> * If a target with fields for temperature, humidity, pressure and acceleration is</a>
<a name="ln496"> * created and populated from data of the sensors end result will be:</a>
<a name="ln497"> *</a>
<a name="ln498"> * -&gt; Temperature, timestamp from TMP117</a>
<a name="ln499"> * -&gt; Humidity from SHTC3</a>
<a name="ln500"> * -&gt; Pressure from DPS310</a>
<a name="ln501"> * -&gt; Acceleration from LIS2DH12</a>
<a name="ln502"> *</a>
<a name="ln503"> * If same firmware is run on a board with only LIS2DH12 populated, end result will be</a>
<a name="ln504"> *</a>
<a name="ln505"> * -&gt; Temperature, timestamp, acceleration from LIS2DH12</a>
<a name="ln506"> * -&gt; RD_FLOAT_INVALID on humidity and pressure.</a>
<a name="ln507"> *</a>
<a name="ln508"> * @param[out] target Data to be populated. Fields must be initially populated with</a>
<a name="ln509"> *                    RD_FLOAT_INVALID.</a>
<a name="ln510"> * @param[in]  provided Data provided by sensor.</a>
<a name="ln511"> * @param[in]  requested Fields to be filled if possible.</a>
<a name="ln512"> */</a>
<a name="ln513">void rd_sensor_data_populate (rd_sensor_data_t * const target,</a>
<a name="ln514">                              const rd_sensor_data_t * const provided,</a>
<a name="ln515">                              const rd_sensor_data_fields_t requested);</a>
<a name="ln516"> </a>
<a name="ln517">/**</a>
<a name="ln518"> * @brief Parse data from provided struct.</a>
<a name="ln519"> *</a>
<a name="ln520"> * @param[in]  provided Data to be parsed.</a>
<a name="ln521"> * @param[in]  requested One data field to be parsed.</a>
<a name="ln522"> * @return     sensor value if found, RD_FLOAT_INVALID if the provided data didn't</a>
<a name="ln523"> *             have a valid value.</a>
<a name="ln524"> */</a>
<a name="ln525">float rd_sensor_data_parse (const rd_sensor_data_t * const provided,</a>
<a name="ln526">                            const rd_sensor_data_fields_t requested);</a>
<a name="ln527"> </a>
<a name="ln528">/**</a>
<a name="ln529"> * @brief Count number of floats required for this data structure.</a>
<a name="ln530"> *</a>
<a name="ln531"> * @param[in]  target Structure to count number of fields from.</a>
<a name="ln532"> * @return     Number of floats required to store the sensor data.</a>
<a name="ln533"> */</a>
<a name="ln534">uint8_t rd_sensor_data_fieldcount (const rd_sensor_data_t * const target);</a>
<a name="ln535"> </a>
<a name="ln536">/**</a>
<a name="ln537"> * @brief Set a desired value to target data.</a>
<a name="ln538"> *</a>
<a name="ln539"> * This function looks up the appropriate assigments on each data field in given target</a>
<a name="ln540"> * and populates it with provided data. Does nothing if there is no appropriate slot</a>
<a name="ln541"> * in target data.</a>
<a name="ln542"> *</a>
<a name="ln543"> * This is a shorthand for @ref rd_sensor_data_populate for only one data field, without</a>
<a name="ln544"> * setting timestamp.</a>
<a name="ln545"> *</a>
<a name="ln546"> * @param[out] target</a>
<a name="ln547"> * @param[in]  field  Quantity to set, exactly one must be set to true.</a>
<a name="ln548"> * @param[in]  value  Value of quantity,</a>
<a name="ln549"> */</a>
<a name="ln550">void rd_sensor_data_set (rd_sensor_data_t * const target,</a>
<a name="ln551">                         const rd_sensor_data_fields_t field,</a>
<a name="ln552">                         const float value);</a>
<a name="ln553"> </a>
<a name="ln554">/**</a>
<a name="ln555"> * @brief Validate that given setting can be set on a sensor which supports only default value.</a>
<a name="ln556"> *</a>
<a name="ln557"> * @param[in,out] input Input: Must be RD_SENSOR_CFG_DEFAULT, _NO_CHANGE, _MIN or _MAX.</a>
<a name="ln558"> *                      Output: _DEFAULT</a>
<a name="ln559"> * @param[in] mode Mode sensor is currently in. Must be sleep to configure sensor.</a>
<a name="ln560"> */</a>
<a name="ln561">rd_status_t validate_default_input_set (uint8_t * const input, const uint8_t mode);</a>
<a name="ln562"> </a>
<a name="ln563">/**</a>
<a name="ln564"> * @brief Validate and get input when only allowed value is default.</a>
<a name="ln565"> *</a>
<a name="ln566"> * @param[out] input Setting of sensor to get. Will be RD_SENSOR_CFG_DEFAULT.</a>
<a name="ln567"> *</a>
<a name="ln568"> * @retval RD_SUCCESS if input is not NULL.</a>
<a name="ln569"> * @retval RD_ERROR_NULL if input is NULL.</a>
<a name="ln570"> */</a>
<a name="ln571">rd_status_t validate_default_input_get (uint8_t * const input);</a>
<a name="ln572"> </a>
<a name="ln573">/**</a>
<a name="ln574"> * @brief Check if sensor has valid data at given index.</a>
<a name="ln575"> *</a>
<a name="ln576"> * Data is considered valid if target-&gt;fields and target-&gt;valid both are set.</a>
<a name="ln577"> * Index is referred to number of fields.</a>
<a name="ln578"> *</a>
<a name="ln579"> * Typical usage:</a>
<a name="ln580"> * @code</a>
<a name="ln581"> * const uint8_t fieldcount = rd_sensor_data_fieldcount(p_data);</a>
<a name="ln582"> * for(uint8_t ii = 0; ii &lt; fieldcount; ii++)</a>
<a name="ln583"> * {</a>
<a name="ln584"> *     if(rd_sensor_has_valid_data(p_data, ii)</a>
<a name="ln585"> *     {</a>
<a name="ln586"> *        do_stuff(p_data-&gt;data[ii], rd_sensor_field_type(p_data, ii));</a>
<a name="ln587"> *     }</a>
<a name="ln588"> * }</a>
<a name="ln589"> * @endcode</a>
<a name="ln590"> *</a>
<a name="ln591"> * @param[in] target Pointer to data to check.</a>
<a name="ln592"> * @param[in] index index of data to check.</a>
<a name="ln593"> * @retval true If data at target-&gt;data[index] has a valid value.</a>
<a name="ln594"> * @retval false If target is NULL, index is higher than fields in data or data at</a>
<a name="ln595"> *               index is not marked as valid.</a>
<a name="ln596"> *</a>
<a name="ln597"> * @note To determine the type of data, use @ref rd_sensor_field_type.</a>
<a name="ln598"> */</a>
<a name="ln599">bool rd_sensor_has_valid_data (const rd_sensor_data_t * const target,</a>
<a name="ln600">                               const uint8_t index);</a>
<a name="ln601"> </a>
<a name="ln602">/**</a>
<a name="ln603"> * @brief Check the type of data at given index.</a>
<a name="ln604"> *</a>
<a name="ln605"> * This function is used to determine what type of data given index has.</a>
<a name="ln606"> *</a>
<a name="ln607"> * Typical usage:</a>
<a name="ln608"> * @code</a>
<a name="ln609"> * rd_sensor_data_bitfield_t type = rd_sensor_field_type(p_data, index);</a>
<a name="ln610"> * if(1 == type.temperature_c)</a>
<a name="ln611"> * {</a>
<a name="ln612"> *    do_stuff_with_temperature (p_data-&gt;data[index])</a>
<a name="ln613"> * }</a>
<a name="ln614"> * @endcode</a>
<a name="ln615"> *</a>
<a name="ln616"> * @param[in] target Data to check</a>
<a name="ln617"> * @param[in] index  Index of field to check.</a>
<a name="ln618"> * @return rd_sensor_data_bitfield_t with field corresponding to index set, or 0 if</a>
<a name="ln619"> *                                   target doesn't have any data type at given index.</a>
<a name="ln620"> */</a>
<a name="ln621">rd_sensor_data_bitfield_t rd_sensor_field_type (const rd_sensor_data_t * const target,</a>
<a name="ln622">        const uint8_t index);</a>
<a name="ln623"> </a>
<a name="ln624">/** @} */</a>
<a name="ln625">#endif</a>

</code></pre>
<div class="balloon" rel="123"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '1U' expression should not be converted from the essential 'unsigned' type to the essential 'signed' type.</p></div>
<div class="balloon" rel="124"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '2U' expression should not be converted from the essential 'unsigned' type to the essential 'signed' type.</p></div>
<div class="balloon" rel="125"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '3U' expression should not be converted from the essential 'unsigned' type to the essential 'signed' type.</p></div>
<div class="balloon" rel="126"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '4U' expression should not be converted from the essential 'unsigned' type to the essential 'signed' type.</p></div>
<div class="balloon" rel="127"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '5U' expression should not be converted from the essential 'unsigned' type to the essential 'signed' type.</p></div>
<div class="balloon" rel="444"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2614/" target="_blank">V2614</a> External identifiers should be distinct. The identifier must contain fewer than 32 characters.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
