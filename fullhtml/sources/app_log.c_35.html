
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>app_log.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file app_log.c</a>
<a name="ln3"> * @author Otso Jousimaa &lt;otso@ojousima.net&gt;</a>
<a name="ln4"> * @date 2021-12-16</a>
<a name="ln5"> * @brief</a>
<a name="ln6"> * Save and retrieve sensor readings to/from flash</a>
<a name="ln7"> * for transmitting to station for sync.</a>
<a name="ln8"> * Allocate static input, output and config memory.</a>
<a name="ln9"> * Readings are blocked into a nearly page size buffer.</a>
<a name="ln10"> * store_block by bumping index up to _DATA_RECORDS_NUM then wrap.</a>
<a name="ln11"> * _log_process establish time for next sample</a>
<a name="ln12"> *              if it's time, collect sensor data and add to input_block and</a>
<a name="ln13"> *              if full write it to flash</a>
<a name="ln14"> * _init log config_set/get to/from flash. and boot_count and</a>
<a name="ln15"> *          _purge_logs erases all log records then garbage collection.</a>
<a name="ln16"> * Use FDS record access routines (not fstore page routines)</a>
<a name="ln17"> *  via rt_flash_free, _store, _load and _flash_gc_run</a>
<a name="ln18"> * Possible fatal error from FDS: delete SPACE_IN_QUEUES,</a>
<a name="ln19"> * https://infocenter.nordicsemi.com/topic/com.nordic.infocenter.sdk5.v15.0.0/lib_fds_functionality.html</a>
<a name="ln20"> * Occurs if flash operations are queued faster than executed.</a>
<a name="ln21"> *</a>
<a name="ln22"> *</a>
<a name="ln23"> * @copyright Ruuvi Innovations Ltd, license BSD-3-Clause.</a>
<a name="ln24"> */</a>
<a name="ln25">#include &quot;app_log.h&quot;</a>
<a name="ln26"> </a>
<a name="ln27">#include &quot;app_config.h&quot;</a>
<a name="ln28">#include &quot;app_testing.h&quot;</a>
<a name="ln29">#include &quot;ruuvi_driver_error.h&quot;</a>
<a name="ln30">#include &quot;ruuvi_driver_sensor.h&quot;</a>
<a name="ln31">#include &quot;ruuvi_library.h&quot;</a>
<a name="ln32">#include &quot;ruuvi_library_compress.h&quot;</a>
<a name="ln33">#include &quot;ruuvi_interface_log.h&quot;</a>
<a name="ln34">#include &quot;ruuvi_interface_yield.h&quot;</a>
<a name="ln35">#include &quot;ruuvi_task_flash.h&quot;</a>
<a name="ln36"> </a>
<a name="ln37">#if RT_FLASH_ENABLED</a>
<a name="ln38"> </a>
<a name="ln39">static inline void LOGI (const char * const msg)</a>
<a name="ln40">{</a>
<a name="ln41">    ri_log (RI_LOG_LEVEL_INFO, msg);</a>
<a name="ln42">}</a>
<a name="ln43"> </a>
<a name="ln44">static inline void LOGD (const char * const msg)</a>
<a name="ln45">{</a>
<a name="ln46">    ri_log (RI_LOG_LEVEL_DEBUG, msg);</a>
<a name="ln47">}</a>
<a name="ln48"> </a>
<a name="ln49">/**</a>
<a name="ln50"> * @addtogroup app_log</a>
<a name="ln51"> */</a>
<a name="ln52">/** @{ */</a>
<a name="ln53"> </a>
<a name="ln54">TESTABLE_STATIC app_log_record_t m_log_input_block;     //!&lt; Block to be stored to flash.</a>
<a name="ln55">TESTABLE_STATIC app_log_record_t</a>
<a name="ln56">m_log_output_block;    //!&lt; Block read from flash for examination.</a>
<a name="ln57"> </a>
<a name="ln58">TESTABLE_STATIC app_log_config_t m_log_config;          //!&lt; Configuration for logging.</a>
<a name="ln59">TESTABLE_STATIC uint64_t</a>
<a name="ln60">m_last_sample_ms;      //!&lt; Timestamp of last processed sample.</a>
<a name="ln61">TESTABLE_STATIC uint32_t         m_boot_count = 0;</a>
<a name="ln62"> </a>
<a name="ln63"> </a>
<a name="ln64">/*</a>
<a name="ln65"> * Store given log record to flash. Keeps track of slots via state variables.</a>
<a name="ln66"> */</a>
<a name="ln67">static rd_status_t store_block (const app_log_record_t * const p_record)</a>
<a name="ln68">{</a>
<a name="ln69">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln70">    uint8_t num_tries = 0;</a>
<a name="ln71">    static uint8_t record_idx = 0;</a>
<a name="ln72"> </a>
<a name="ln73">    do</a>
<a name="ln74">    {</a>
<a name="ln75">        // If loop went past the last record, wrap.</a>
<a name="ln76">        uint8_t  record_slot = (record_idx + num_tries) % APP_FLASH_LOG_DATA_RECORDS_NUM;</a>
<a name="ln77">        uint16_t target_record = (APP_FLASH_LOG_DATA_RECORD_PREFIX &lt;&lt; 8u) + record_slot;</a>
<a name="ln78">        // Free space for new record if there already is one.</a>
<a name="ln79">        err_code = rt_flash_free (APP_FLASH_LOG_FILE, target_record);</a>
<a name="ln80">        char msg[128];</a>
<a name="ln81">        snprintf (msg, sizeof (msg), &quot;Storing logs in record #%04X.\n&quot;, target_record);</a>
<a name="ln82">        LOGD (msg);</a>
<a name="ln83">        // Clear out error if there was no record to erase out of way.</a>
<a name="ln84">        err_code &amp;= ~RD_ERROR_NOT_FOUND;</a>
<a name="ln85"> </a>
<a name="ln86">        while (rt_flash_busy()) { ri_yield(); }</a>
<a name="ln87"> </a>
<a name="ln88">        // Run GC to actually release the space of old record.</a>
<a name="ln89">        err_code |= rt_flash_gc_run ();</a>
<a name="ln90"> </a>
<a name="ln91">        while (rt_flash_busy()) { ri_yield(); }</a>
<a name="ln92"> </a>
<a name="ln93">        err_code |= rt_flash_store (APP_FLASH_LOG_FILE, target_record,</a>
<a name="ln94">                                    p_record, sizeof (app_log_record_t));</a>
<a name="ln95"> </a>
<a name="ln96">        while (rt_flash_busy()) { ri_yield(); }</a>
<a name="ln97"> </a>
<a name="ln98">        RD_ERROR_CHECK (err_code, ~RD_ERROR_FATAL);</a>
<a name="ln99">        num_tries++;             // Try the next block if there was error.</a>
<a name="ln100">    } while ( (RD_SUCCESS != err_code) &amp;&amp; (num_tries &lt; APP_FLASH_LOG_DATA_RECORDS_NUM));</a>
<a name="ln101"> </a>
<a name="ln102">    if (RD_SUCCESS == err_code)</a>
<a name="ln103">    {</a>
<a name="ln104">        // Increment the record to the slot that was successful</a>
<a name="ln105">        record_idx += num_tries;</a>
<a name="ln106">        record_idx = record_idx % APP_FLASH_LOG_DATA_RECORDS_NUM;</a>
<a name="ln107">    }</a>
<a name="ln108"> </a>
<a name="ln109">    return err_code;</a>
<a name="ln110">}</a>
<a name="ln111"> </a>
<a name="ln112">static rd_status_t purge_logs (void)</a>
<a name="ln113">{</a>
<a name="ln114">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln115">    LOGI (&quot;Free all &amp; GC\n&quot;);</a>
<a name="ln116"> </a>
<a name="ln117">    for (uint8_t record_idx = 0; record_idx &lt; APP_FLASH_LOG_DATA_RECORDS_NUM; record_idx++)</a>
<a name="ln118">    {</a>
<a name="ln119">        err_code |= rt_flash_free (APP_FLASH_LOG_FILE,</a>
<a name="ln120">                                   (APP_FLASH_LOG_DATA_RECORD_PREFIX &lt;&lt; 8u) + record_idx);</a>
<a name="ln121"> </a>
<a name="ln122">        while (rt_flash_busy()) { ri_yield(); }</a>
<a name="ln123">    }</a>
<a name="ln124"> </a>
<a name="ln125">    err_code &amp;= ~RD_ERROR_NOT_FOUND; // It doesn't matter if there was no data to erase.</a>
<a name="ln126">    err_code |= rt_flash_gc_run ();</a>
<a name="ln127">    return err_code;</a>
<a name="ln128">}</a>
<a name="ln129"> </a>
<a name="ln130">TESTABLE_STATIC rd_status_t app_log_increment_boot_count (void)</a>
<a name="ln131">{</a>
<a name="ln132">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln133">    err_code |= rt_flash_load (APP_FLASH_LOG_FILE,</a>
<a name="ln134">                               APP_FLASH_LOG_BOOT_COUNTER_RECORD,</a>
<a name="ln135">                               &amp;m_boot_count, sizeof (m_boot_count));</a>
<a name="ln136"> </a>
<a name="ln137">    if ( (RD_SUCCESS == err_code) || (RD_ERROR_NOT_FOUND == err_code))</a>
<a name="ln138">    {</a>
<a name="ln139">        m_boot_count++;</a>
<a name="ln140">        err_code = rt_flash_store (APP_FLASH_LOG_FILE,</a>
<a name="ln141">                                   APP_FLASH_LOG_BOOT_COUNTER_RECORD,</a>
<a name="ln142">                                   &amp;m_boot_count, sizeof (m_boot_count));</a>
<a name="ln143">    }</a>
<a name="ln144"> </a>
<a name="ln145">    char msg[128];</a>
<a name="ln146">    snprintf (msg, sizeof (msg), &quot;Boot count: %lu\n&quot;, m_boot_count); //-V576</a>
<a name="ln147">    LOGI (msg);</a>
<a name="ln148">    return err_code;</a>
<a name="ln149">}</a>
<a name="ln150"> </a>
<a name="ln151">rd_status_t app_log_init (void)</a>
<a name="ln152">{</a>
<a name="ln153">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln154">    // Defaults get overwritten by flash load and stored if the load fails.</a>
<a name="ln155">    app_log_config_t config =</a>
<a name="ln156">    {</a>
<a name="ln157">        .interval_s = APP_LOG_INTERVAL_S,</a>
<a name="ln158">        .overflow   = APP_LOG_OVERFLOW,</a>
<a name="ln159">        .fields = {</a>
<a name="ln160">            .datas.temperature_c = APP_LOG_TEMPERATURE_ENABLED,</a>
<a name="ln161">            .datas.humidity_rh   = APP_LOG_HUMIDITY_ENABLED,</a>
<a name="ln162">            .datas.pressure_pa   = APP_LOG_PRESSURE_ENABLED</a>
<a name="ln163">        }</a>
<a name="ln164">    };</a>
<a name="ln165">#   if APP_FLASH_LOG_CONFIG_NVM_ENABLED</a>
<a name="ln166">    err_code = rt_flash_load (APP_FLASH_LOG_FILE, APP_FLASH_LOG_CONFIG_RECORD,</a>
<a name="ln167">                              &amp;config, sizeof (config));</a>
<a name="ln168">#   endif</a>
<a name="ln169"> </a>
<a name="ln170">    if (RD_ERROR_NOT_FOUND == err_code) //-V547</a>
<a name="ln171">    {</a>
<a name="ln172">        err_code = rt_flash_store (APP_FLASH_LOG_FILE, APP_FLASH_LOG_CONFIG_RECORD,</a>
<a name="ln173">                                   &amp;config, sizeof (config));</a>
<a name="ln174">    }</a>
<a name="ln175"> </a>
<a name="ln176">    if (RD_SUCCESS == err_code) //-V547</a>
<a name="ln177">    {</a>
<a name="ln178">        memcpy (&amp;m_log_config, &amp;config, sizeof (config));</a>
<a name="ln179">        LOGI (&quot;purge\n&quot;);</a>
<a name="ln180">        err_code |= purge_logs();</a>
<a name="ln181">    }</a>
<a name="ln182"> </a>
<a name="ln183">    err_code |= app_log_increment_boot_count();</a>
<a name="ln184">    return err_code;</a>
<a name="ln185">}</a>
<a name="ln186"> </a>
<a name="ln187">rd_status_t app_log_process (const rd_sensor_data_t * const sample)</a>
<a name="ln188">{</a>
<a name="ln189">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln190">    uint64_t next_sample_ms = m_last_sample_ms + (m_log_config.interval_s * 1000u);</a>
<a name="ln191">    uint32_t end_timestamp = sample-&gt;timestamp_ms / 1000U;</a>
<a name="ln192">    LOGD (&quot;Sample received\n&quot;);</a>
<a name="ln193"> </a>
<a name="ln194">    if (0 == m_last_sample_ms) { next_sample_ms = 0; } // Always store first sample.</a>
<a name="ln195"> </a>
<a name="ln196">    if (next_sample_ms &lt;= sample-&gt;timestamp_ms) //Check if new sample should be processed</a>
<a name="ln197">    {</a>
<a name="ln198">        LOGD (&quot;Storing sample\n&quot;);</a>
<a name="ln199">        app_log_element_t element =</a>
<a name="ln200">        {</a>
<a name="ln201">            .timestamp_s   = sample-&gt;timestamp_ms / 1000u,</a>
<a name="ln202">            .temperature_c = rd_sensor_data_parse (sample, RD_SENSOR_TEMP_FIELD),</a>
<a name="ln203">            .humidity_rh   = rd_sensor_data_parse (sample, RD_SENSOR_HUMI_FIELD),</a>
<a name="ln204">            .pressure_pa   = rd_sensor_data_parse (sample, RD_SENSOR_PRES_FIELD),</a>
<a name="ln205">        };</a>
<a name="ln206"> </a>
<a name="ln207">        if (APP_LOG_MAX_SAMPLES &gt; m_log_input_block.num_samples)</a>
<a name="ln208">        { m_log_input_block.storage[m_log_input_block.num_samples++] = element; }</a>
<a name="ln209"> </a>
<a name="ln210">        if (m_log_input_block.num_samples &gt;= APP_LOG_MAX_SAMPLES)</a>
<a name="ln211">        {</a>
<a name="ln212">            LOGI (&quot;Storing block\n&quot;);</a>
<a name="ln213">            m_log_input_block.end_timestamp_s = end_timestamp;</a>
<a name="ln214">            err_code |= store_block (&amp;m_log_input_block);</a>
<a name="ln215">            RD_ERROR_CHECK (err_code, RD_SUCCESS);</a>
<a name="ln216">            memset (&amp;m_log_input_block, 0, sizeof (m_log_input_block));         // zero input_block</a>
<a name="ln217">            m_log_input_block.start_timestamp_s = end_timestamp;</a>
<a name="ln218">        }</a>
<a name="ln219"> </a>
<a name="ln220">        m_last_sample_ms = sample-&gt;timestamp_ms;</a>
<a name="ln221">    }</a>
<a name="ln222"> </a>
<a name="ln223">    return err_code;</a>
<a name="ln224">}</a>
<a name="ln225"> </a>
<a name="ln226">/**</a>
<a name="ln227"> * @brief Load new block to be read if needed.</a>
<a name="ln228"> *</a>
<a name="ln229"> * Can also copy input block to</a>
<a name="ln230"> * output block if there's no more stored blocks in flash.</a>
<a name="ln231"> */</a>
<a name="ln232">static rd_status_t app_log_read_load_block (app_log_read_state_t * const p_rs)</a>
<a name="ln233">{</a>
<a name="ln234">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln235"> </a>
<a name="ln236">    if ( (0 == p_rs-&gt;element_idx)</a>
<a name="ln237">            &amp;&amp; (0 == p_rs-&gt;page_idx))</a>
<a name="ln238">    {</a>
<a name="ln239">        // Clear out previous state</a>
<a name="ln240">        err_code |= rt_flash_load (APP_FLASH_LOG_FILE,</a>
<a name="ln241">                                   (APP_FLASH_LOG_DATA_RECORD_PREFIX &lt;&lt; 8u) + p_rs-&gt;page_idx,</a>
<a name="ln242">                                   &amp;m_log_output_block, sizeof (m_log_output_block));</a>
<a name="ln243">        p_rs-&gt;page_idx++;</a>
<a name="ln244">    }</a>
<a name="ln245">    else if ( (APP_FLASH_LOG_DATA_RECORDS_NUM &gt; p_rs-&gt;page_idx)</a>
<a name="ln246">              &amp;&amp; (p_rs-&gt;element_idx &gt;= m_log_output_block.num_samples))</a>
<a name="ln247">    {</a>
<a name="ln248">        // Returns NOT_FOUND if page IDX is not in flash.</a>
<a name="ln249">        err_code |= rt_flash_load (APP_FLASH_LOG_FILE,</a>
<a name="ln250">                                   (APP_FLASH_LOG_DATA_RECORD_PREFIX &lt;&lt; 8u) + p_rs-&gt;page_idx,</a>
<a name="ln251">                                   &amp;m_log_output_block, sizeof (m_log_output_block));</a>
<a name="ln252">        p_rs-&gt;page_idx++;</a>
<a name="ln253">        p_rs-&gt;element_idx = 0;</a>
<a name="ln254">    }</a>
<a name="ln255">    else if ( (APP_FLASH_LOG_DATA_RECORDS_NUM == p_rs-&gt;page_idx)</a>
<a name="ln256">              &amp;&amp; (p_rs-&gt;element_idx &gt;= m_log_output_block.num_samples))</a>
<a name="ln257">    {</a>
<a name="ln258">        memcpy (&amp;m_log_output_block, &amp;m_log_input_block, sizeof (m_log_output_block));</a>
<a name="ln259">        p_rs-&gt;page_idx++;</a>
<a name="ln260">        p_rs-&gt;element_idx = 0;</a>
<a name="ln261">    }</a>
<a name="ln262">    else {} // No action needed.</a>
<a name="ln263"> </a>
<a name="ln264">    // Zero out state if block was not found</a>
<a name="ln265">    if (RD_ERROR_NOT_FOUND == err_code)</a>
<a name="ln266">    {</a>
<a name="ln267">        memset (&amp;m_log_output_block, 0, sizeof (m_log_output_block));</a>
<a name="ln268">    }</a>
<a name="ln269"> </a>
<a name="ln270">    return err_code;</a>
<a name="ln271">}</a>
<a name="ln272"> </a>
<a name="ln273">/**</a>
<a name="ln274"> * @brief Forward read state to first next valid element.</a>
<a name="ln275"> *</a>
<a name="ln276"> * @param [in, out] p_rs State of log read operation. Updated to next valid element.</a>
<a name="ln277"> * @retval RD_SUCCESS p_rs points to a valid element</a>
<a name="ln278"> * @retval RD_ERROR_NOT_FOUND if block doesn't have a valid element.</a>
<a name="ln279"> */</a>
<a name="ln280">static rd_status_t app_log_read_fast_forward (app_log_read_state_t * const p_rs)</a>
<a name="ln281">{</a>
<a name="ln282">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln283">    uint64_t ts_s  = m_log_output_block.storage[p_rs-&gt;element_idx].timestamp_s;</a>
<a name="ln284">    uint64_t ts_ms = ts_s * 1000LLU;</a>
<a name="ln285"> </a>
<a name="ln286">    while ( (p_rs-&gt;oldest_element_ms &gt; ts_ms)</a>
<a name="ln287">            &amp;&amp; (p_rs-&gt;element_idx &lt; m_log_output_block.num_samples))</a>
<a name="ln288">    {</a>
<a name="ln289">        ts_s  = m_log_output_block.storage[p_rs-&gt;element_idx].timestamp_s;</a>
<a name="ln290">        ts_ms = ts_s * 1000LLU;</a>
<a name="ln291">        p_rs-&gt;element_idx++;</a>
<a name="ln292">    }</a>
<a name="ln293"> </a>
<a name="ln294">    if (p_rs-&gt;element_idx &gt;= m_log_output_block.num_samples) { err_code |= RD_ERROR_NOT_FOUND; }</a>
<a name="ln295"> </a>
<a name="ln296">    return err_code;</a>
<a name="ln297">}</a>
<a name="ln298"> </a>
<a name="ln299">static rd_status_t app_log_read_populate (rd_sensor_data_t * const sample,</a>
<a name="ln300">        app_log_read_state_t * const p_rs)</a>
<a name="ln301">{</a>
<a name="ln302">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln303"> </a>
<a name="ln304">    // Last memory block is the current RAM buffer, so we have valid data</a>
<a name="ln305">    // when APP_FLASH_LOG_DATA_RECORDS_NUM + 1 == p_rs-&gt;page_idx</a>
<a name="ln306">    if ( (APP_FLASH_LOG_DATA_RECORDS_NUM + 1) &lt; p_rs-&gt;page_idx)</a>
<a name="ln307">    {</a>
<a name="ln308">        err_code |= RD_ERROR_NOT_FOUND;</a>
<a name="ln309">    }</a>
<a name="ln310">    else if (p_rs-&gt;element_idx &lt; m_log_output_block.num_samples)</a>
<a name="ln311">    {</a>
<a name="ln312">        const app_log_element_t * const p_el = &amp;m_log_output_block.storage[p_rs-&gt;element_idx];</a>
<a name="ln313">        rd_sensor_data_set (sample, RD_SENSOR_TEMP_FIELD, p_el-&gt;temperature_c);</a>
<a name="ln314">        rd_sensor_data_set (sample, RD_SENSOR_HUMI_FIELD, p_el-&gt;humidity_rh);</a>
<a name="ln315">        rd_sensor_data_set (sample, RD_SENSOR_PRES_FIELD, p_el-&gt;pressure_pa);</a>
<a name="ln316">        sample-&gt;timestamp_ms = ( (uint64_t) (p_el-&gt;timestamp_s)) * 1000LLU;</a>
<a name="ln317">        p_rs-&gt;element_idx++;</a>
<a name="ln318">    }</a>
<a name="ln319">    else {} // No action required.</a>
<a name="ln320"> </a>
<a name="ln321">    return err_code;</a>
<a name="ln322">}</a>
<a name="ln323"> </a>
<a name="ln324">rd_status_t app_log_read (rd_sensor_data_t * const sample,</a>
<a name="ln325">                          app_log_read_state_t * const p_rs)</a>
<a name="ln326">{</a>
<a name="ln327">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln328"> </a>
<a name="ln329">    if ( (NULL != sample) &amp;&amp; (NULL != p_rs))</a>
<a name="ln330">    {</a>
<a name="ln331">        // Load new block if needed</a>
<a name="ln332">        do</a>
<a name="ln333">        {</a>
<a name="ln334">            err_code = app_log_read_load_block (p_rs);</a>
<a name="ln335"> </a>
<a name="ln336">            // Decompress block -todo.</a>
<a name="ln337">            // Check if ths block contains data in desired time range - TODO</a>
<a name="ln338">            // Fast forward to start of desired time range.</a>
<a name="ln339">            if (RD_SUCCESS == err_code) { err_code |= app_log_read_fast_forward (p_rs); }</a>
<a name="ln340">        } while ( (err_code != RD_SUCCESS)</a>
<a name="ln341"> </a>
<a name="ln342">                  &amp;&amp; (p_rs-&gt;page_idx &lt;= APP_FLASH_LOG_DATA_RECORDS_NUM));</a>
<a name="ln343"> </a>
<a name="ln344">        err_code |= app_log_read_populate (sample, p_rs); // Populate record</a>
<a name="ln345">    }</a>
<a name="ln346">    else { err_code = RD_ERROR_NULL; }</a>
<a name="ln347"> </a>
<a name="ln348">    return err_code;</a>
<a name="ln349">}</a>
<a name="ln350"> </a>
<a name="ln351">rd_status_t app_log_config_set (const app_log_config_t * const configuration)</a>
<a name="ln352">{</a>
<a name="ln353">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln354">    uint32_t end_timestamp = m_log_input_block.end_timestamp_s;</a>
<a name="ln355"> </a>
<a name="ln356">    if (NULL == configuration) { err_code |= RD_ERROR_NULL; }</a>
<a name="ln357">    else</a>
<a name="ln358">    {</a>
<a name="ln359">        err_code |= rt_flash_store (APP_FLASH_LOG_FILE, APP_FLASH_LOG_CONFIG_RECORD,</a>
<a name="ln360">                                    &amp;configuration, sizeof (configuration));</a>
<a name="ln361"> </a>
<a name="ln362">        if (RD_SUCCESS == err_code)</a>
<a name="ln363">        {</a>
<a name="ln364">            err_code |= store_block (&amp;m_log_input_block);</a>
<a name="ln365">            RD_ERROR_CHECK (err_code, RD_SUCCESS);</a>
<a name="ln366">            memset (&amp;m_log_input_block, 0, sizeof (m_log_input_block));</a>
<a name="ln367">            m_log_input_block.start_timestamp_s = end_timestamp;</a>
<a name="ln368">            memcpy (&amp;m_log_config, configuration, sizeof (m_log_config));</a>
<a name="ln369">        }</a>
<a name="ln370">    }</a>
<a name="ln371"> </a>
<a name="ln372">    return err_code;</a>
<a name="ln373">}</a>
<a name="ln374"> </a>
<a name="ln375">rd_status_t app_log_config_get (app_log_config_t * const configuration)</a>
<a name="ln376">{</a>
<a name="ln377">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln378">    err_code |= rt_flash_load (APP_FLASH_LOG_FILE, APP_FLASH_LOG_CONFIG_RECORD,</a>
<a name="ln379">                               configuration, sizeof (app_log_config_t));</a>
<a name="ln380">    memcpy (configuration, &amp;m_log_config, sizeof (m_log_config));</a>
<a name="ln381">    return err_code;</a>
<a name="ln382">}</a>
<a name="ln383"> </a>
<a name="ln384">void app_log_purge_flash (void)</a>
<a name="ln385">{</a>
<a name="ln386">    ri_flash_purge();</a>
<a name="ln387">}</a>
<a name="ln388"> </a>
<a name="ln389">#else     // RT_FLASH_ENABLED  </a>
<a name="ln390">rd_status_t app_log_init (void)                                                 // dummy</a>
<a name="ln391">{</a>
<a name="ln392">    return RD_SUCCESS;</a>
<a name="ln393">}</a>
<a name="ln394">rd_status_t app_log_process (const rd_sensor_data_t * const sample)             // dummy</a>
<a name="ln395">{</a>
<a name="ln396">    return RD_SUCCESS;</a>
<a name="ln397">}</a>
<a name="ln398">rd_status_t app_log_config_get (app_log_config_t * const configuration)         // dummy</a>
<a name="ln399">{</a>
<a name="ln400">    return RD_SUCCESS;</a>
<a name="ln401">}</a>
<a name="ln402">rd_status_t app_log_config_set (const app_log_config_t * const configuration)  // dummy</a>
<a name="ln403">{</a>
<a name="ln404">    return RD_SUCCESS;</a>
<a name="ln405">}</a>
<a name="ln406">rd_status_t app_log_read (rd_sensor_data_t * const sample,                     // dummy</a>
<a name="ln407">                          app_log_read_state_t * const p_read_state)</a>
<a name="ln408">{</a>
<a name="ln409">    return RD_ERROR_NOT_FOUND;</a>
<a name="ln410">}</a>
<a name="ln411"> </a>
<a name="ln412">void app_log_purge_flash (void)                                                 // dummy</a>
<a name="ln413">{</a>
<a name="ln414">    return;</a>
<a name="ln415">}</a>
<a name="ln416">#endif    // RT_FLASH_ENABLED</a>

</code></pre>
<div class="balloon" rel="76"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2568/" target="_blank">V2568</a> Both operands of the '%' operator should have the same essential type. The current types are: 'signed' and 'unsigned'.</p></div>
<div class="balloon" rel="76"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(record_idx + num_tries) % ((16U) - 2U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="77"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '((0xF0U) << 8u) + record_slot' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="79"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0xF0U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="81"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2600/" target="_blank">V2600</a> The function with the 'snprintf' name should not be used.</p></div>
<div class="balloon" rel="93"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0xF0U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="94"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the 'sizeof (app_log_record_t)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="106"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the 'record_idx % ((16U) - 2U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="119"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0xF0U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="120"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '((0xF0U) << 8u) + record_idx' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="133"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0xF0U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="134"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0xEFU)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="140"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0xF0U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="141"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0xEFU)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="146"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2600/" target="_blank">V2600</a> The function with the 'snprintf' name should not be used.</p></div>
<div class="balloon" rel="170"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2594/" target="_blank">V2594</a> Controlling expressions should not be invariant. The result of the '(1U << 2U) == err_code' expression in the 'if' statement is always false.</p></div>
<div class="balloon" rel="172"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0xF0U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="172"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0x01U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="176"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2594/" target="_blank">V2594</a> Controlling expressions should not be invariant. The result of the '(0U) == err_code' expression in the 'if' statement is always true.</p></div>
<div class="balloon" rel="190"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2613/" target="_blank">V2613</a> Operand that is a composite expression has more narrow essential type than the other operand.</p></div>
<div class="balloon" rel="191"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the 'sample->timestamp_ms / 1000U' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="194"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2568/" target="_blank">V2568</a> Both operands of the '==' operator should have the same essential type. The current types are: 'signed' and 'unsigned'.</p></div>
<div class="balloon" rel="194"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="207"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2568/" target="_blank">V2568</a> Both operands of the '-' operator should have the same essential type. The current types are: 'signed' and 'unsigned'.</p></div>
<div class="balloon" rel="210"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2568/" target="_blank">V2568</a> Both operands of the '-' operator should have the same essential type. The current types are: 'signed' and 'unsigned'.</p></div>
<div class="balloon" rel="236"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2568/" target="_blank">V2568</a> Both operands of the '==' operator should have the same essential type. The current types are: 'signed' and 'unsigned'.</p></div>
<div class="balloon" rel="237"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2568/" target="_blank">V2568</a> Both operands of the '==' operator should have the same essential type. The current types are: 'signed' and 'unsigned'.</p></div>
<div class="balloon" rel="240"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0xF0U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="241"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '((0xF0U) << 8u) + p_rs->page_idx' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="249"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0xF0U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="250"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '((0xF0U) << 8u) + p_rs->page_idx' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="253"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="260"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="306"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2568/" target="_blank">V2568</a> Both operands of the '+' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="359"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0xF0U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="359"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0x01U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="378"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0xF0U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="378"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0x01U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="19"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2587/" target="_blank">V2587</a> The '//' and '/*' character sequences should not appear within comments.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
